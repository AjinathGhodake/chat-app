"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = exports.runExecutor = exports.validateProject = exports.printRunHelp = void 0;
const tslib_1 = require("tslib");
const minimist = require("minimist");
const params_1 = require("../shared/params");
const print_help_1 = require("../shared/print-help");
const workspace_1 = require("../shared/workspace");
const chalk = require("chalk");
const logger_1 = require("../shared/logger");
const rxjs_for_await_1 = require("rxjs-for-await");
function throwInvalidInvocation() {
    throw new Error(`Specify the project name and the target (e.g., nx run proj:build)`);
}
function parseRunOpts(cwd, args, defaultProjectName) {
    const runOptions = params_1.convertToCamelCase(minimist(args, {
        boolean: ['help', 'prod'],
        string: ['configuration', 'project'],
        alias: {
            c: 'configuration',
        },
    }));
    const help = runOptions.help;
    if (!runOptions._ || !runOptions._[0]) {
        throwInvalidInvocation();
    }
    // eslint-disable-next-line prefer-const
    let [project, target, configuration] = runOptions._[0].split(':');
    if (!project && defaultProjectName) {
        logger_1.logger.debug(`No project name specified. Using default project : ${chalk.bold(defaultProjectName)}`);
        project = defaultProjectName;
    }
    if (runOptions.configuration) {
        configuration = runOptions.configuration;
    }
    if (runOptions.prod) {
        configuration = 'production';
    }
    if (runOptions.project) {
        project = runOptions.project;
    }
    if (!project || !target) {
        throwInvalidInvocation();
    }
    const res = { project, target, configuration, help, runOptions };
    delete runOptions['help'];
    delete runOptions['_'];
    delete runOptions['c'];
    delete runOptions['configuration'];
    delete runOptions['prod'];
    delete runOptions['project'];
    return res;
}
function printRunHelp(opts, schema) {
    print_help_1.printHelp(`nx run ${opts.project}:${opts.target}`, schema);
}
exports.printRunHelp = printRunHelp;
function validateProject(workspace, projectName) {
    const project = workspace.projects[projectName];
    if (!project) {
        throw new Error(`Could not find project "${projectName}"`);
    }
}
exports.validateProject = validateProject;
function isPromise(v) {
    return typeof v.then === 'function';
}
function promiseToIterator(v) {
    return tslib_1.__asyncGenerator(this, arguments, function* promiseToIterator_1() {
        yield yield tslib_1.__await(yield tslib_1.__await(v));
    });
}
function iteratorToProcessStatusCode(i) {
    var i_1, i_1_1;
    var e_1, _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let r;
        try {
            for (i_1 = tslib_1.__asyncValues(i); i_1_1 = yield i_1.next(), !i_1_1.done;) {
                r = i_1_1.value;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (i_1_1 && !i_1_1.done && (_a = i_1.return)) yield _a.call(i_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (!r) {
            throw new Error('NX Executor has not returned or yielded a response.');
        }
        return r.success ? 0 : 1;
    });
}
function createImplicitTargetConfig(proj, targetName) {
    return {
        executor: '@nrwl/workspace:run-script',
        options: {
            script: targetName,
        },
    };
}
function runExecutorInternal({ project, target, configuration, }, options, root, cwd, workspace, isVerbose, printHelp) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        validateProject(workspace, project);
        const ws = new workspace_1.Workspaces(root);
        const proj = workspace.projects[project];
        const targetConfig = proj.targets && proj.targets[target]
            ? proj.targets[target]
            : createImplicitTargetConfig(proj, target);
        const [nodeModule, executor] = targetConfig.executor.split(':');
        const { schema, implementationFactory } = ws.readExecutor(nodeModule, executor);
        if (printHelp) {
            printRunHelp({ project, target }, schema);
            process.exit(0);
        }
        const combinedOptions = params_1.combineOptionsForExecutor(options, configuration, targetConfig, schema, project, ws.relativeCwd(cwd));
        if (ws.isNxExecutor(nodeModule, executor)) {
            const implementation = implementationFactory();
            const r = implementation(combinedOptions, {
                root: root,
                target: targetConfig,
                workspace: workspace,
                projectName: project,
                cwd: cwd,
                isVerbose: isVerbose,
            });
            return (isPromise(r) ? promiseToIterator(r) : r);
        }
        else {
            const observable = yield (yield Promise.resolve().then(() => require('./ngcli-adapter'))).scheduleTarget(root, {
                project,
                target,
                configuration,
                runOptions: combinedOptions,
            }, isVerbose);
            return rxjs_for_await_1.eachValueFrom(observable);
        }
    });
}
/**
 * Loads and invokes executor.
 *
 * This is analogous to invoking executor from the terminal, with the exception
 * that the params aren't parsed from the string, but instead provided parsed already.
 *
 * Apart from that, it works the same way:
 *
 * - it will load the workspace configuration
 * - it will resolve the target
 * - it will load the executor and the schema
 * - it will load the options for the appropriate configuration
 * - it will run the validations and will set the default
 * - and, of course, it will invoke the executor
 *
 * Example:
 *
 * ```typescript
 * for await (const s of await runExecutor({project: 'myproj', target: 'serve'}, {watch: true}, context)) {
 *   // s.success
 * }
 * ```
 *
 * Note that the return value is a promise of an iterator, so you need to await before iterating over it.
 */
function runExecutor(targetDescription, options, context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return yield runExecutorInternal(targetDescription, options, context.root, context.cwd, context.workspace, context.isVerbose, false);
    });
}
exports.runExecutor = runExecutor;
function run(cwd, root, args, isVerbose) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const ws = new workspace_1.Workspaces(root);
        return params_1.handleErrors(isVerbose, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const workspace = ws.readWorkspaceConfiguration();
            const defaultProjectName = ws.calculateDefaultProjectName(cwd, workspace);
            const opts = parseRunOpts(cwd, args, defaultProjectName);
            return iteratorToProcessStatusCode(yield runExecutorInternal(opts, opts.runOptions, root, cwd, workspace, isVerbose, opts.help));
        }));
    });
}
exports.run = run;
//# sourceMappingURL=run.js.map