"use strict";
/**
 * Adapted from original ng-packagr
 *
 * Exclude the UMD bundling and minification
 * which is not needed for incremental compilation
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NX_WRITE_BUNDLES_TRANSFORM = exports.NX_WRITE_BUNDLES_TRANSFORM_TOKEN = exports.nxWriteBundlesTransform = void 0;
const tslib_1 = require("tslib");
const injection_js_1 = require("injection-js");
const transform_1 = require("ng-packagr/lib/graph/transform");
const transform_di_1 = require("ng-packagr/lib/graph/transform.di");
const nodes_1 = require("ng-packagr/lib/ng-package/nodes");
const rollup_1 = require("ng-packagr/lib/flatten/rollup");
const log = require("ng-packagr/lib/utils/log");
const array_1 = require("ng-packagr/lib/utils/array");
exports.nxWriteBundlesTransform = transform_1.transformFromPromise((graph) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const entryPoint = graph.find(nodes_1.isEntryPointInProgress());
    const { destinationFiles, entryPoint: ngEntryPoint, tsConfig, } = entryPoint.data;
    const cache = entryPoint.cache;
    // Add UMD module IDs for dependencies
    const dependencyUmdIds = entryPoint
        .filter(nodes_1.isEntryPoint)
        .map((ep) => ep.data.entryPoint)
        .reduce((prev, ep) => {
        prev[ep.moduleId] = ep.umdId;
        return prev;
    }, {});
    const { fesm2015, esm2015 } = destinationFiles;
    const opts = {
        sourceRoot: tsConfig.options.sourceRoot,
        amd: { id: ngEntryPoint.amdId },
        umdModuleIds: Object.assign(Object.assign({}, ngEntryPoint.umdModuleIds), dependencyUmdIds),
        entry: esm2015,
        dependencyList: getDependencyListForGraph(graph),
    };
    log.info('Bundling to FESM2015');
    // @ts-ignore
    cache.rollupFESMCache = yield rollup_1.rollupBundleFile(Object.assign(Object.assign({}, opts), { moduleName: ngEntryPoint.moduleId, format: 'es', dest: fesm2015, 
        // @ts-ignore
        cache: cache.rollupFESMCache }));
}));
/** Get all list of dependencies for the entire 'BuildGraph' */
function getDependencyListForGraph(graph) {
    // We need to do this because if A dependency on bundled B
    // And A has a secondary entry point A/1 we want only to bundle B if it's used.
    // Also if A/1 depends on A we don't want to bundle A thus we mark this a dependency.
    const dependencyList = {
        dependencies: [],
        bundledDependencies: [],
    };
    for (const entry of graph.filter(nodes_1.isEntryPoint)) {
        const { bundledDependencies = [], dependencies = {}, peerDependencies = {}, } = entry.data.entryPoint.packageJson;
        dependencyList.bundledDependencies = array_1.unique(dependencyList.bundledDependencies.concat(bundledDependencies));
        dependencyList.dependencies = array_1.unique(dependencyList.dependencies.concat(Object.keys(dependencies), Object.keys(peerDependencies), entry.data.entryPoint.moduleId));
    }
    if (dependencyList.bundledDependencies.length) {
        log.warn(`Inlining of 'bundledDependencies' has been deprecated in version 5 and will be removed in future versions.` +
            '\n' +
            `List the dependency in the 'peerDependencies' section instead.`);
    }
    return dependencyList;
}
exports.NX_WRITE_BUNDLES_TRANSFORM_TOKEN = new injection_js_1.InjectionToken(`nx.v1.writeBundlesTransform`);
exports.NX_WRITE_BUNDLES_TRANSFORM = transform_di_1.provideTransform({
    provide: exports.NX_WRITE_BUNDLES_TRANSFORM_TOKEN,
    useFactory: () => exports.nxWriteBundlesTransform,
});
//# sourceMappingURL=write-bundles.js.map